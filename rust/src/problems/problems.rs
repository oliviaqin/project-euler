use std::cmp;

pub fn p001() -> u64 {
    println!(
        "If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\nFind the sum of all the multiples of 3 or 5 below 1000."
    );

    let mut sum: u64 = 0;

    let mut odd_number: u64 = 1;

    for _ in 1..=33 {
        let group_sum: u64 = odd_number * 30 * 4;
        sum = sum + group_sum;
        odd_number = odd_number + 2;
    }

    sum = sum + 993 + 996 + 999;

    odd_number = 1;

    for _ in 1..=10 {
        let group_sum = odd_number * 100 * 9 + odd_number * 100 + 50;
        sum = sum + group_sum;
        odd_number = odd_number + 2;
    }

    sum = sum - 1000;

    println!("The final sum is {sum}");

    sum
}

pub fn p002() -> u64 {
    println!(
        "Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: \n 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... \nBy considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms."
    );

    let mut cur = 1;
    let mut prev = 1;

    let mut sum: u64 = 2;

    // You can create a fibonacci with multiples of 2...can you do it with
    for n in 2..34 {
        let temp = cur;
        if n % 3 == 0 {
            cur = cur + prev + 1;
            if 2 * cur > 4000000 {
                break;
            }
            sum = sum + 2 * cur;
        } else {
            cur = cur + prev;
        }
        prev = temp;
    }

    println!("The sum is {sum}");

    sum
}

pub fn p003() -> u64 {
    let mut large_number: u64 = 600851475143;
    // let mut large_number: u64 = 13195;
    let mut biggest_divisor: u64 = 1;

    let largest_integer_sqrt = large_number.isqrt();
    // Divide by odd numbers
    for n in 3..largest_integer_sqrt {
        if n % 2 == 0 {
            continue;
        }
        if n >= large_number.isqrt() {
            biggest_divisor = large_number;
            break;
        }
        if large_number % n == 0 {
            large_number = large_number / n;
            biggest_divisor = n;
        }
    }

    println!("The biggest prime divisor is: {biggest_divisor}");

    biggest_divisor
}

fn is_palindrome(num: u64) -> bool {
    // Returns whether num is a palindrome
    let mut reverse: u64 = 0;
    let mut curr: u64 = num;

    while curr > 0 {
        let remainder: u64 = curr % 10;
        curr = curr / 10;
        reverse = reverse * 10 + remainder;
    }

    return num == reverse;
}

pub fn p004() -> u64 {
    let mut largest_palindrome: u64 = 0;

    for i in (880..999).rev() {
        for j in (879..991).rev().step_by(11) {
            if is_palindrome(i * j) {
                largest_palindrome = cmp::max(largest_palindrome, i * j);
            }
        }
    }

    println!("Largest palindrome is {largest_palindrome}");

    largest_palindrome
}

// warning answers below!

mod tests {
    use super::*;

    #[test]
    fn test_p001() {
        assert_eq!(p001(), 233168);
    }

    #[test]
    fn test_p002() {
        assert_eq!(p002(), 4613732);
    }

    #[test]
    fn test_p003() {
        assert_eq!(p003(), 6857);
    }

    #[test]
    fn test_p004() {
        assert_eq!(p004(), 906609);
    }

    #[test]
    fn test_is_palindrome() {
        assert_eq!(is_palindrome(9119), true);
        assert_eq!(is_palindrome(10), false);
        assert_eq!(is_palindrome(91119), true);
        assert_eq!(is_palindrome(11), true);
    }
}
